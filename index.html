<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Am207 by 72L</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Genetic Programming for the Computational Discovery of Trading Rules</h1>
        <p>AM207 Spring 2014 Final Project</p>
        
        <ol style="list-style: none;">
          <li><a href="#intro-and-theory">Introduction and Theory</a></li>
          <li><a href="#data">Data</a></li>
          <li><a href="#approach">Approach</a></li>
          <li><a href="#results">Results</a></li>
          <li><a href="#conc">Conclusions and Future Directions</a></li>
        </ol>
        
        
        <p class="view"><a href="https://github.com/72L/am207">View the Project on GitHub <small>72L/am207</small></a></p>

      </header>
      <section>
        <h3>
<a name="intro-and-theory" class="anchor" href="#intro-and-theory"><span class="octicon octicon-link"></span></a>Introduction and Theory</h3>

<h4>What are Trading Strategies?</h4>

<p>Technical trading strategies are used to determine buy and sell signals based on time series stock data. In the purest sense, trading strategies operate with only input from time series data and do not consider fundamentals (i.e. balance sheets, news, income statements) used by analysts considering a company’s inherent value. Instead, trading strategies employ indicators, which are derived time series calculated from raw price or volume time series data. For example, one possible technical trading strategy could use the 200-day moving average (MA(200)) and the 50-day moving average (MA(50)) indicators. A buy signal is generated when the MA(50) crosses above the MA(200), signalling a recent upward trend. Conversely, a sell signal would be generated when the MA(50) crosses below the MA(200). Other commonly used indicators include moving window standard deviations and momentum, which is the price difference between the ends of a moving window.
</p>

<p>Trading strategies explored by academics have been met with varying levels of success. Ratner et al. tested a series of moving average trading strategies on different world markets, but found that transaction costs diminished most of the gains made relative to a buy-and-hold strategy [1]. Strictly speaking, technical trading strategies do not predict future prices. Rather, indicators are used to generate buy/sell signals in real time with present and historical data. Some researchers have combined methods of prediction with trading strategies to great success [2]; however, the current project will focus solely on trading strategies.</p>

<h4>Motivation</h4>
<p>The trading strategies described thus far have some heuristic rationalization because they were developed by humans. It is reasonable to posit, however, that successful trading rules should not be limited by human intuition or experience. This project addresses whether new, unintuitive, and profitable trading strategies can be discovered with a stochastic algorithm called genetic programming. New strategies generated this way may perhaps capture underlying, yet unknown trends in the market.</p>

<h4>What is Genetic Programming?</h4>
<p>Genetic algorithms optimize a fitness function by simulating natural selection. Members of a population, which represent candidate solutions, are mutated randomly over time. At each time step or generation, each member is given probability to reproduce clones proportional to their respective fitness. If designed well, over time, the population will achieve higher and higher fitness, eventually reaching the optimal point of the fitness function. </p>
<p>Genetic programming (GP), a type genetic algorithm, optimizes a set of rules or programs that transform data in highly non-linear ways. Programs are represented as trees, where each node is an operation performed with the two subtrees of data below it. Results of each operation node are successively combined from the bottom up. The final dataset is the output of the highest level node, processed by all the operations below it. Recent studies have applied the genetic programming framework to model hadronic collisions [3], predict travel time [4], and predict the consumption of natural gas [5]. </p>
<p>Genetic programming has been used extensively in the field of finance to generate and evaluate trading strategies, which are easily represented as trees (see below). GP has been used to generate trading strategies for US indices (S&P500 and Dow Jones Index) [6, 7, 8], Foreign exchange markets [9, 10], and individual Canadian stocks [11]. These studies were not able to obtain rules that provided consistent returns on a risk-adjusted basis, especially with transaction costs.</p>

<h4>What did I do?</h4>
<p>In this project, I use Genetic Programming to generate and evaluate trading strategies on individual S&P 500 stock tickers. Perhaps an approach that uses customized strategies for each stock in a portfolio will be able to better exploit market inefficiencies (and therefore achieve better returns) compared to a strategy that trades solely with the entire index.</p>



<h3>
<a name="data" class="anchor" href="#data"><span class="octicon octicon-link"></span></a>Data</h3>

<p>Historical daily adjusted closing prices and volumes from years 1999 to 2013 of stocks in the S&P 500 were downloaded from Yahoo! Finance. Only stocks with at least 15 years of history available on Yahoo! Finance were considered (n = 312). This allowed splitting of the time series data into a 10-year training set (1999 to 2008) and a 5-year test set (2009 to 2013). </p>
<p>The Global Industry Classification Standard (GICS) sector labels given to each ticker were used for sector analysis. Our data set of 312 tickers contained 48 tickers from the Financials sector, 47 from Industrials, 42 from Consumer Discretionary, 34 from Health Care, 33 from Information Technology, 28 from Consumer Staples, 27 from Energy, 26 from Utilities, 23 from Materials, and 4 from Telecommunications Services. </p>



<h3>
<a name="approach" class="anchor" href="#approach"><span class="octicon octicon-link"></span></a>Approach</h3>

<h4>Trading Strategy Tree Representation</h4>
<p>A trading strategy is composed of two trees: one that encodes the buy signals and one that encodes the sell signals. For example, a possible trading strategy using Bollinger Bands [12] is represented by the two trees in the figure below. A sell signal is generated when the sell tree returns true. That is, the investor will sell when the price falls below the lower bollinger band, which is calculated as MA(20) - 2*SD(20) , where MA(x)  and SD(x) are the x-day moving window average and standard deviation, respectively. Similarly, a buy signal is generated when the price rises above the upper bollinger band, calculated as MA(20) + 2*SD(20).</p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940863/315caaf4-d991-11e3-8f6f-d29256c5155e.png" style="display: block;
    margin-left: auto;
    margin-right: auto"/>

<p>To construct the trading strategy trees, a set of seven operations were defined (Table 1). These operations comprise the joining nodes, such as those represented by circles in Figure 1.
</p>

<table cellpadding="0" cellspacing="0" class="c39"><tbody><tr class="c35"><td class="c26"><p class="c21"><span class="c1 c3">O</span><span class="c1 c3">perations</span></p></td><td class="c22"><p class="c21"><span class="c44 c1 c3">Input</span></p></td><td class="c36"><p class="c21"><span class="c1 c3 c44">Output</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Add (+)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">the vector sum</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Subtract (-)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">the vector difference (order dependence)</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Norm </span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">the absolute value of the vector difference </span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Multiply (x)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">a scalar and a time series vector</span></p></td><td class="c36"><p class="c10"><span class="c3 c2 c7">the scalar multiple of the time series vector</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c3 c2">Divide (</span><span class="c3 c2 c27">&divide;)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">each entry of the first vector is divided by the second (order dependence)</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Greater Than (&gt;)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">Boolean of entry-wise comparison (order dependence)</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Less Than (&lt;)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">Boolean of entry-wise comparison (order dependence)</span></p></td></tr></tbody></table>

<p>Operations act on a set of indicators (Table 2), such as those represented by rectangles in Figure 1. The derived indicators were pre-calculated from the raw price or volume data before GP simulation. This allowed fast evaluation of the trading strategy trees. 
</p>
<p>Moving windows used in the calculation of the derived time series were chosen from a truncated Fibonacci number set, where numbers above 10 continue to increase by multiples of 10 up to 365. This was chosen arbitrarily to limit the number of pre-calculated time series that had to be stored onto system memory. </p>
<p>The simulation was initialized with a population of 300 identical Bollinger Band trading strategy tree pairs.  The set of 300 was mutated as described below to produce an initial population. The population size of 300 was kept constant.</p>

<h4>Fitness</h4>

<p>Given the buy and sell signals calculated from the trading strategies, the fitness function was determined by simulating the sequential buying and selling of one share of the stock. Thus, two consecutive buy signals would only result in one action - the first buy. “Lossless” trading behavior is implemented, where a sell signal is accepted only if there is profit to be made. </p>
<p>The absolute return minus a small $0.01/stock transaction cost was used as a measure of fitness during evolution. The transaction cost was included to penalize strategies with too many transactions (overfitting), yet the cost was made small to limit this effect on the genetic algorithm. For data analysis of trees after GP selection, a more realistic 0.1% transaction cost was used (see below). </p>
<p>To cross validate, the training set was split into 4 segments (2.5 years each), and the absolute return was calculated on each segment using the lossless trading behavior described above.  The minimum of the returns from the four segments was used as the fitness for the entire trading rule. At each time step or generation, trading strategies (represented as trees) were given probability to reproduce clones proportional to their respective fitness. The genetic algorithm was run for 500 generations for each stock ticker. </p>

<h4>Mutation, Recombination, and Polyclonality</h4>
<p>At the start of each generation, each trading strategy in the population was mutated with a certain probability. The mutations altered the trees by changing randomly the input indicators (Table 2) (probability = P = 0.1), the length of the moving window (P = 0.05), the constant of multiplication for the multiplication operator (P =  0.5, gaussian proposal distribution step size = 1), or the operations at the nodes (Table 1) (P = 0.05). Care was taken to ensure that nodes containing boolean operations remained boolean after mutation. </p>
<p>Two types of recombination were defined and both recombination rules were each applied to 30 randomly selected pairs of trading strategies at each generation. The first type of recombination was performed by swapping sub-branches between the buy or the sell trees of each trading strategy. The second recombination defined was a simple swapping of entire buy or sell trees between any two trading strategies. </p>
<p>Polyclonality is defined as the number of unique trading strategies in the population and was monitored over the course of evolution. When polyclonality dropped to 20 or below, the current population would be replaced by a population mutated from the most optimal solution in the evolutionary history. </p>

<h4>Analysis of results</h4>
<p>For each of the optimal trading strategies from each stock ticker GP run, a realistic return was calculated as the percent return in excess of a S&P 500 buy-and-hold strategy (+23.7% in the training period and +3.88% in the test period). A fixed 0.1% transaction cost was implemented per transaction, corresponding to a $7 fixed fee [13] from investing in batches of stocks worth $7000. We thus define the annualized adjusted excess return as the annualized percent return in excess of a buy-and-hold strategy on the S&P500 index in the same time period, minus a 0.1% transaction cost. </p>

<h4>Tree Similarity Calculation</h4>
<p>To compare the trading strategies from each of the 312 GP runs, a similarity score was developed. Each buy and sell tree from each trading strategy was applied on 15000 days of S&P 500 historical data, producing a 15000 entry binary vector corresponding to buy/sell signals. The euclidian distance between these vectors were calculated for all pairwise tree comparisons. The additive inverse normalized distance was then used to generate a similarity score from 0 to 1. This “functional” comparison was rationalized because similar trees should, in principle, generate similar buy/sell signals. </p>
<p>Figure 2 shows two buy trees (A&B) that were deemed similar (scoreAB = 0.940) and a third tree (C) that was deemed not similar compared to the other two (scoreAC = 0.0003, scoreBC = 0.0015). In broad strokes, one could rationalize why trees A and B might have been scored as similar. The root (top) node of tree B can be flipped such that the root operation of both trees A and B are “greater than” a certain volume lag. In addition, it is plausible that the current volume minus the minimum volume over the last three days (tree B) is an approximation of the standard deviation of volume over the last 8 days (tree A). Certainly, these trees produced very similar buy signals over the course of roughly 41 years on the S&P 500 index, suggesting that they are functionally similar even though it may be hard to intuitively rationalize why they would be. It is also clear that tree C is different from A and B because it includes price data that is combined with volume data.</p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940865/3161a518-d991-11e3-8d4b-e324c29cadfc.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>


<h3>
<a name="results" class="anchor" href="#results"><span class="octicon octicon-link"></span></a>Results</h3>


<h4>Typical GP Results on Single Stocks</h4>
<p>Figure 3 shows GP parameters over time during a typical genetic evolution simulation. The training set fitness (top graph, blue line) generally increases over time, but the test set fitness (top graph, red line) does not rise. This is a sign of overfitting. However, the population mean fitnesses in the training and test sets remain similar until generation 60, where the mean training set fitness starts to rise above the mean test set fitness. This is another sign of overfitting, and indicates that the algorithm is not yet perfect; more work could be done to improve the GP algorithm. </p>
Polyclonality in the time course shown remains relatively high, suggesting that the current mutations are relatively small. A higher mutation rate or more radical mutations could be introduced into the system in hope of achieving better trading strategies by taking larger leaps. </p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940868/316937e2-d991-11e3-975d-6ef34a8af34e.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
<h4>Genetic Programming on Multiple Stocks</h4>
<p>GP was run on historical data from 312 tickers listed in the S&P 500. Figure 4 shows the distributions of annualized adjusted excess returns of optimal trading strategies generated from the 10 year training period (horizontal histogram) and the 5 year test period (vertical histogram). The annualized adjusted excess return is the percent return, accounting for a 0.1% transaction cost, in excess of a buy-and-hold strategy on the S&P500 index in the same time period (S&P 500 performance: +23.7% in the training period and +3.88% in the test period).</p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940869/316b7822-d991-11e3-9460-632c718fd211.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
<p>The mean annualized adjusted excess return is 105.6% and 11.4% from the training period and the test period, respectively. This indicates that there is some amount of overfitting present in the current form of the algorithm. However, the S&P 500 buy-and-hold strategy had a much greater return in the training period (23.7%) than in the test period (3.88%), suggesting that the training period (1999 to 2008) was a bull market. A bull market would give better returns in general for all trading strategies, which may partially (in addition to overfitting) explain higher yields for the training set.</p>   
<p>The semi-strong efficient market hypothesis (EMH) states that the prices at any one time is a reflection of all the available information about the company and the market [14]. Some claim the fact that specific technical strategies work disproves the EMH because consistent profits would indicate that there are market inefficiencies to exploit. It is intuitive to suppose that the market is more efficient for stocks that are well known and watched (high volume), while relatively inefficient for less well-known tickers. Using the trading rules optimized for each stock ticker, the returns from optimized trading strategies are shown versus average trade volume of each ticker (Figure 5).</p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940866/3164a222-d991-11e3-807d-33498940b169.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
<p>The graph does not show a clear correlation between trading volume and return. However, the roughly triangular shape of the 2D distribution in Figure 5 may potentially suggest that stocks traded at higher volume contain higher market efficiency and are therefore less likely to result in higher returns. Indeed, restricting the portfolio to S&P tickers with average daily volumes under 1 million almost doubles the mean test period annualized adjusted excess return to 19.1%.</p> 
<p>Stock tickers were classified into sectors based on the GICS classification scheme. Figure 6 shows the annualized adjusted excess returns from all tickers in each sector, along with a kernel density estimate of their distribution. It appears that the Consumer Staples, Materials, Health Care, and Utilities sectors contain the most market inefficiencies because the mean of the distribution of returns clearly appear higher than 0%. </p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940867/3166e438-d991-11e3-8c28-52b04f4f2903.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
<h4>Comparing the Trading Strategies</h4>
<p>312 trading strategies (from 312 stock tickers), each with buy and sell signal-generating trees, were generated from the GP algorithms. The indicators that ended up being incorporated into the optimal buy and sell trees were compiled and counted (Figure 7). Interestingly, the volume lag indicators for 5, 13, and 33 days were very frequency used in sell trees, while the most frequently used indicators in the buy trees are volume SD(33) and price MA(13). Note that although the operations performed on these indicators higher up in the tree could be different, the fact that these are used frequently may be an indication of their usefulness. These specific indicators (which are surprisingly mostly based on volume) appear to hold the most information in terms of discovering market inefficiencies to exploit. </p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940864/315f9da4-d991-11e3-8ea0-06ea1b1f0cf5.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
<p>Since the trees varied in size, operations used, and indicators used, a simple, 1D similarity score was developed (see Approach section) to functionally compare the trees. Briefly, for each pairwise comparison of trees in the dataset, the similarity score was calculated using the buy/sell signals they generated on 41 years of S&P 500 price data. Using the similarities as edge weights on a graph where nodes represent trees, the ensemble of 312 buy trees were visualized (Figure 8). A graph was produced for the sell trees as well (not shown) and it was very similar. </p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940862/315a213a-d991-11e3-8f26-56106826a3f7.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
<p>At least six clusters of buy trees are observed, and it is assumed that each of these clusters represent functionally groups of different trading strategies. Each node/ticker is sized by the test period annualized adjusted return and colored by sector. Buy and sell trees do not appear to cluster by sector (X2 = xx, p = xx), suggesting that the trading strategies may be specific to each stock ticker, rather than generalizable to that ticker’s sector. To test the appropriateness of this clustering algorithm, future work should focus on comparing the performance of buy rules used on stocks within a cluster and that for stocks outside the cluster.</p>
<p>Trees also do not appear to cluster by size (X2 = xx, p = xx), indicating that successful returns do not come solely from a particular class of trading strategies. Rather, each of the type of trading strategy represented by each cluster yields variable success rates, probably more dependent on individual tickers. </p>




<h3>
<a name="conc" class="anchor" href="#conc"><span class="octicon octicon-link"></span></a>Conclusions and Future Directions</h3>

<p>Genetic programming was used to select a set of trees that performed well on each of the 312 S&P 500 stock tickers studied. The annualized adjusted excess return is defined as the percentage return in excess of that from a buy-and-hold strategy on the S&P 500 index with a 0.1% transaction fee. Averaging over the portfolio of 312 trading strategies generated with GP, the mean annualized adjusted excess return is 105.6% and 11.4% in the training period and in the test period, respectively. </p>
<p>Evidence of overfitting in the current model suggests that there is more model optimization and validation to be done. One way to approach the problem is to split the training data into more validation sets, which would reduce the tendency for a specific part of the training data to disproportionately affect the fitness. Another approach is to train the trading strategies on longer periods of training data, potentially giving the algorithm exposure to a greater range of price movement patterns. In order to improve the training and test set returns, more operations and indicators could be included, such as the Price-Earnings Ratio. Historic Price-Earnings Ratios are not provided by Yahoo! Finance, so it was not included in the current project due to time constraints. </p>
<p>It would also be interesting to apply each generated trading strategy on stock tickers that were not used to train it. This would give an indication of how generalizable specific trading strategies are to other stock tickers and whether the GP overfit trading strategies to the ticker data used to train it. </p>
<p>GP was shown to be a powerful method for selecting profitable trading strategies given a large number of operations and the resultant high dimension of possible trading strategy trees. The results suggest that indeed, a trading algorithm which customizes strategies to individual stocks of a portfolio is better able to exploit market inefficiencies compared to an algorithm that only optimizes over the combined index.   </p>
  
<h3>
<a name="refs" class="anchor" href="#refs"><span class="octicon octicon-link"></span></a>References</h3>


<ol>
<li>Ratner, M., & Leal, R. P. (1999). Tests of technical trading strategies in the emerging equity markets of Latin America and Asia. <em>Journal of Banking & Finance, 23</em>(12), 1887-1905. </li>
<li>Gencay, R. (1998). Optimization of technical trading strategies and the profitability in security markets. <em>Economics Letters, 59</em> (2), 249-254. </li>
<li>El-Khateeb, E., Radi, A., El-Bakry, S. Y., & El-Bakry, M. Y. (2014). Modeling Hadronic Collisions Using Genetic Programming Approach. </li>
<li>Elhenawy, M., Chen, H., & Rakha, H. A. (2014). Dynamic travel time prediction using data clustering and genetic programming. <em>Transportation Research Part C: Emerging Technologies, 42</em>, 82-98. </li>
<li>Harvey, D., & Todd, M. (2014). Automated selection of damage detection features by genetic programming. In <em>Topics in Modal Analysis, Volume 7</em> (pp. 9-16). Springer New York. </li>
<li>Allen, F., & Karjalainen, R. (1999). Using genetic algorithms to find technical trading strategies. <em>Journal of financial Economics, 51</em> (2), 245-271. </li>
<li>Brock, W., Lakonishok, J., & LeBaron, B. (1992). Simple technical trading strategies and the stochastic properties of stock returns. <em>The Journal of Finance, 47</em> (5), 1731-1764. </li>
<li>Chen, S. H., & Yeh, C. H. (1997). Toward a computable approach to the efficient market hypothesis: an application of genetic programming. <em>Journal of Economic Dynamics and Control, 21</em> (6), 1043-1063. </li>
<li>Dempster, M. A. H., Payne, T. W., Romahi, Y., & Thompson, G. W. (2001). Computational learning techniques for intraday FX trading using popular technical indicators. <em>Neural Networks, IEEE Transactions on, 12</em> (4), 744-754. </li>
<li>Neely, C., Weller, P., & Dittmar, R. (1997). Is technical analysis in the foreign exchange market profitable? A genetic programming approach. <em>Journal of Financial and Quantitative Analysis, 32</em> (04), 405-426. </li>
<li>Potvin, J. Y., Soriano, P., & Vallée, M. (2004). Generating trading strategies on the stock markets with genetic programming. Computers & Operations Research, 31(7), 1033-1047. </li>
<li>Bollinger, J. (2001). <em>Bollinger on Bollinger bands</em>. McGraw Hill Professional. </li>
<li>Merrill Edge. (2014). Pricing. http://www.merrilledge.com/pricing</li>
<li>Malkiel, B. G., & Fama, E. F. (1970). Efficient capital markets: A review of theory and empirical work*. <em>The journal of Finance, 25</em>(2), 383-417. </li>
</ol>
  
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/72L">72L</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
