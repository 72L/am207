<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Am207 by 72L</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Genetic Programming for the Computational Discovery of Trading Rules</h1>
        <p>AM 207 Spring 2014 Final Project<br/>Ryan Lee</p>
        
        <ol style="list-style: none;">
          <li><a href="#intro-and-theory">Introduction and Theory</a></li>
          <li><a href="#results">Results</a></li>
          <li><a href="#approach">Approach</a></li>
          <li><a href="#conc">Conclusions and Future Directions</a></li>
          <li><a href="#refs">References</a></li>
        </ol>
        
        <p class="view"><a href="https://github.com/72L/am207">View the Project iPython Notebook</a><br/>
        <a href="https://github.com/72L/am207">View the Project on GitHub</a></p>

      </header>
      <section>
        <h3>
<a name="intro-and-theory" class="anchor" href="#intro-and-theory"><span class="octicon octicon-link"></span></a>Introduction and Theory</h3>

<p class="lead">Technical trading strategies are used to determine buy and sell signals based on time series stock data.</p><p> Trading strategies employ indicators, which are derived time series calculated from raw price or volume time series data. Typical indicators are moving average, momentum, and standard deviation. 
</p>

<p>Strictly speaking, technical trading strategies do not predict future prices. Rather, indicators are used to generate buy/sell signals in real time with present and historical data.</p>

<p class="lead">Common trading strategies have some heuristic rationalization but successful trading rules should not be limited by human intuition or experience.</p><p> This project addresses whether new, unintuitive, and profitable trading strategies can be discovered with a stochastic algorithm called genetic programming. New strategies generated this way may perhaps capture underlying, yet unknown trends in the market.</p>

<p>Genetic algorithms optimize a fitness function by simulating natural selection. Members of a population, which represent candidate solutions, are mutated randomly over time. At each time step or generation, each member is given probability to reproduce clones proportional to their respective fitness. If designed well, over time, the population will achieve higher and higher fitness, eventually reaching the optimal point of the fitness function. </p>

<p class="lead">Genetic programming (GP), a type genetic algorithm, optimizes a set of rules or programs that transform data in highly non-linear ways.</p><p> Programs are represented as trees, where each node is an operation performed with the two subtrees of data below it. Results of each operation node are successively combined from the bottom up. The final dataset is the output of the highest level node, processed by all the operations below it. Recent studies have applied the genetic programming framework to model hadronic collisions [3], predict travel time [4], and predict the consumption of natural gas [5]. </p>

<p>Genetic programming has been used extensively in the field of finance to generate and evaluate trading strategies, which are easily represented as trees (see below). GP has been used to generate trading strategies for US indices (S&P500 and Dow Jones Index) [6, 7, 8], Foreign exchange markets [9, 10], and individual Canadian stocks [11]. These studies were not able to obtain rules that provided consistent returns on a risk-adjusted basis, especially with transaction costs.</p>

<p class="lead">Genetic Programming was used to automatically generate and evaluate thousands of trading strategies on individual S&P 500 stock tickers.</p><p> Perhaps an approach that uses customized strategies for each stock in a portfolio will be able to better exploit market inefficiencies (and therefore achieve better returns) compared to a strategy that trades solely with the entire index.</p>

<h3>
<a name="results" class="anchor" href="#results"><span class="octicon octicon-link"></span></a>Results</h3>

<p class="lead">The mean annualized adjusted excess return is 105.6% and 11.4% from the training period and the test period, respectively.</p>
<p>GP was run on historical data from 312 tickers listed in the S&P 500. Figure 4 shows the distributions of annualized adjusted excess returns of optimal trading strategies generated from the 10 year training period (horizontal histogram) and the 5 year test period (vertical histogram). The annualized adjusted excess return is the percent return, accounting for a 0.1% transaction cost, in excess of a buy-and-hold strategy on the S&P500 index in the same time period (S&P 500 performance: +23.7% in the training period and +3.88% in the test period).</p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940869/316b7822-d991-11e3-9460-632c718fd211.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
    <small><strong>Figure 4. Annualized adjusted excess returns from the test and training periods.</strong> Results are from the GP-generated optimal trading strategies from 312 tickers listed in the S&P 500. The difference in scale in the training set axis versus the test set axis indicates overfitting. However, both distributions of returns have means above 0%. 
</small>
 
<p>The mean annualized adjusted excess return is 105.6% and 11.4% from the training period and the test period, respectively. This indicates that there is some amount of overfitting present in the current form of the algorithm. However, the S&P 500 buy-and-hold strategy had a much greater return in the training period (23.7%) than in the test period (3.88%), suggesting that the training period (1999 to 2008) was a bull market. A bull market would give better returns in general for all trading strategies, which may partially (in addition to overfitting) explain higher yields for the training set.</p>   

<p class="lead">Consumer Staples, Materials, Health Care, and Utilities sectors contain the most market inefficiencies</p>
<p>Stock tickers were classified into sectors based on the GICS classification scheme. Figure 1 shows the annualized adjusted excess returns from all tickers in each sector, along with a kernel density estimate of their distribution. It appears that the Consumer Staples, Materials, Health Care, and Utilities sectors contain the most market inefficiencies because the mean of the distribution of returns clearly appear higher than 0%. </p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940867/3166e438-d991-11e3-8c28-52b04f4f2903.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
    <small>
      <strong>Figure 1. Annualized adjusted excess returns from stocks in each GICS sector.</strong> A kernel density estimate of the distribution is plotted, along with the actual returns from each ticker. Market inefficiency in each sector can be approximated by determining the extent to which the distribution is above the  0% return mark.     </small>
  
<p class="lead">The most freqeuncy used indicators are volume-based.</p>
<p>312 trading strategies (from 312 stock tickers), each with buy and sell signal-generating trees, were generated from the GP algorithms. The indicators that ended up being incorporated into the optimal buy and sell trees were compiled and counted (Figure 2). Interestingly, the volume lag indicators for 5, 13, and 33 days were very frequency used in sell trees, while the most frequently used indicators in the buy trees are volume SD(33) and price MA(13). Note that although the operations performed on these indicators higher up in the tree could be different, the fact that these are used frequently may be an indication of their usefulness. These specific indicators (which are surprisingly mostly based on volume) appear to hold the most information in terms of discovering market inefficiencies to exploit. </p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940864/315f9da4-d991-11e3-8ea0-06ea1b1f0cf5.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
    <smaLL><STRONG>Figure 2. The frequency of indicator use in buy and sell trees.</strong> Each point represents a specific indicator over a specific moving window length. The colors indicate the type of indicator, such as MA, or SD. The most highly used indicators are labeled with their specific descriptions. </smaLL>

<p class="lead">Buy and sell trees do not appear to cluster by sector or profitability.</p>
<p>Since the trees varied in size, operations used, and indicators used, a simple, 1D similarity score was developed (see Approach section) to functionally compare the trees. Briefly, for each pairwise comparison of trees in the dataset, the similarity score was calculated using the buy/sell signals they generated on 41 years of S&P 500 price data. Using the similarities as edge weights on a graph where nodes represent trees, the ensemble of 312 buy trees were visualized (Figure 3). A graph was produced for the sell trees as well (not shown) and it was very similar. </p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940862/315a213a-d991-11e3-8f26-56106826a3f7.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
    <small><strong>Figure 3. Graph of buy trees linked by similarity.</strong> Each of the 312 nodes represent a stock ticker for which a buy tree was generated using GP. The weight of the edge represents how similar the trees are based on a similarity score (See Approach section). To better visualize clusters, edges with weights below 0.4 were eliminated from the graph. The size of each node represents the test period annualized adjusted return.</small>
    
<p>At least six clusters of buy trees are observed, and it is assumed that each of these clusters represent functionally groups of different trading strategies. Each node/ticker is sized by the test period annualized adjusted return and colored by sector. Buy and sell trees do not appear to cluster by sector, suggesting that the trading strategies may be specific to each stock ticker, rather than generalizable to that ticker’s sector. To test the appropriateness of this clustering algorithm, future work should focus on comparing the performance of buy rules used on stocks within a cluster and that for stocks outside the cluster.</p>
<p>Trees also do not appear to cluster by size, indicating that successful returns do not come solely from a particular class of trading strategies. Rather, each of the type of trading strategy represented by each cluster yields variable success rates, probably more dependent on individual tickers. </p>




<h3>
<a name="approach" class="anchor" href="#approach"><span class="octicon octicon-link"></span></a>Approach</h3>

<h4>Data</h4>

<p>Historical daily adjusted closing prices and volumes from years 1999 to 2013 of stocks in the S&P 500 were downloaded from Yahoo! Finance. Only stocks with at least 15 years of history available on Yahoo! Finance were considered (n = 312). This allowed splitting of the time series data into a 10-year training set (1999 to 2008) and a 5-year test set (2009 to 2013). </p>

<h4>Trading Strategy Tree Representation</h4>
<p>A trading strategy is composed of two trees: one that encodes the buy signals and one that encodes the sell signals. For example, a possible trading strategy using Bollinger Bands [12] is represented by the two trees in the figure below. A sell signal is generated when the sell tree returns true. That is, the investor will sell when the price falls below the lower bollinger band, which is calculated as MA(20) - 2*SD(20) , where MA(x)  and SD(x) are the x-day moving window average and standard deviation, respectively. Similarly, a buy signal is generated when the price rises above the upper bollinger band, calculated as MA(20) + 2*SD(20).</p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940863/315caaf4-d991-11e3-8f6f-d29256c5155e.png" style="display: block;
    margin-left: auto;
    margin-right: auto"/>
  <small><strong>Figure 4. Two trees representing one possible buy/sell strategy.</strong> This strategy uses Bollinger Bands, which are two indicators calculated as ± 20-day standard deviations from the 20-day moving average. One would (A) buy when the price falls below the lower bollinger band and (B) sell when the price goes above the upper Bollinger Band. </small>
  

<p>To construct the trading strategy trees, a set of seven operations were defined (Table 1). These operations comprise the joining nodes, such as those represented by circles in Figure 4.
</p>

<table cellpadding="0" cellspacing="0" class="c39"><tbody><tr class="c35"><td class="c26"><p class="c21"><span class="c1 c3">O</span><span class="c1 c3">perations</span></p></td><td class="c22"><p class="c21"><span class="c44 c1 c3">Input</span></p></td><td class="c36"><p class="c21"><span class="c1 c3 c44">Output</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Add (+)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">the vector sum</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Subtract (-)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">the vector difference (order dependence)</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Norm </span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">the absolute value of the vector difference </span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Multiply (x)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">a scalar and a time series vector</span></p></td><td class="c36"><p class="c10"><span class="c3 c2 c7">the scalar multiple of the time series vector</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c3 c2">Divide (</span><span class="c3 c2 c27">&divide;)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">each entry of the first vector is divided by the second (order dependence)</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Greater Than (&gt;)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">Boolean of entry-wise comparison (order dependence)</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Less Than (&lt;)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">Boolean of entry-wise comparison (order dependence)</span></p></td></tr></tbody></table>
<small>
  <strong>Table 1. Operations defined in the branching nodes (circles) of the trees.</strong> Two broad categories of operations were defined - those that output boolean vectors, and those that output real-valued vectors. Only operations within the same category were switched randomly during mutation. 
</small>

<p>Operations act on a set of indicators (Table 2), such as those represented by rectangles in Figure 4.
</p>

<table cellpadding="0" cellspacing="0" class="c32"><tbody><tr class="c31"><td class="c15"><p class="c14"><span class="c1 c8 c13">Time Series</span></p></td><td class="c6"><p class="c14"><span class="c1 c8 c13 c22">Description</span></p></td></tr><tr class="c12"><td class="c15"><p class="c17"><span class="c9 c1 c8">Price</span></p></td><td class="c6"><p class="c17"><span class="c9 c1 c8">Daily adjusted closing prices, adjusted for dividends and splits. </span></p></td></tr><tr class="c12"><td class="c15"><p class="c17"><span class="c9 c1 c8">Volume</span></p></td><td class="c6"><p class="c17"><span class="c9 c1 c8">Daily trade volumes. </span></p></td></tr><tr class="c12"><td class="c15"><p class="c17"><span class="c1 c8">Diff(</span><span class="c3 c1 c8">n</span><span class="c9 c1 c8">)</span></p></td><td class="c6"><p class="c17"><span class="c1 c8">The momentum over the past </span><span class="c3 c1 c8">n</span><span class="c9 c1 c8">&nbsp;days. </span></p></td></tr><tr class="c12"><td class="c15"><p class="c17"><span class="c1 c8">MA(</span><span class="c3 c1 c8">n</span><span class="c9 c1 c8">)</span></p></td><td class="c6"><p class="c17"><span class="c1 c8">The moving average over past </span><span class="c3 c1 c8">n</span><span class="c9 c1 c8">&nbsp;days. </span></p></td></tr><tr class="c12"><td class="c15"><p class="c17"><span class="c1 c8">SD(</span><span class="c3 c1 c8">n</span><span class="c9 c1 c8">)</span></p></td><td class="c6"><p class="c17"><span class="c1 c8">The moving standard deviation over the past </span><span class="c3 c1 c8">n</span><span class="c9 c1 c8">&nbsp;days.</span></p></td></tr><tr class="c12"><td class="c15"><p class="c17"><span class="c1 c8">Min(</span><span class="c3 c1 c8">n</span><span class="c9 c1 c8">)</span></p></td><td class="c6"><p class="c17"><span class="c1 c8">The minimum price of the past </span><span class="c3 c1 c8">n </span><span class="c9 c1 c8">days. </span></p></td></tr><tr class="c12"><td class="c15"><p class="c17"><span class="c1 c8">Max(</span><span class="c3 c1 c8">n</span><span class="c1 c8 c9">)</span></p></td><td class="c6"><p class="c17"><span class="c1 c8">The maximum price of the past </span><span class="c3 c1 c8">n </span><span class="c9 c1 c8">days. </span></p></td></tr><tr class="c12"><td class="c15"><p class="c17"><span class="c1 c8">Lag(</span><span class="c3 c1 c8">n</span><span class="c9 c1 c8">)</span></p></td><td class="c6"><p class="c17"><span class="c1 c8">The price </span><span class="c3 c1 c8">n</span><span class="c9 c1 c8">&nbsp;days ago. </span></p></td></tr></tbody></table>
<small>
  <strong>Table 2. Indicators defined in the end nodes (rectangles) of the trading strategy trees.</strong> Two broad categories of indicators were defined: raw time series (Price and Volume) and derived indicators. The six derived indicators were calculated on each raw time series, with the exception of Diff(n), which was calculated on the only price data. 

</small>


<p>The simulation was initialized with a population of 300 identical Bollinger Band trading strategy tree pairs.  The set of 300 was mutated as described below to produce an initial population. The population size of 300 was kept constant.</p>

<h4>Fitness</h4>

<p>Given the buy and sell signals calculated from the trading strategies, the fitness function was determined by simulating the sequential buying and selling of one share of the stock. Thus, two consecutive buy signals would only result in one action - the first buy. “Lossless” trading behavior is implemented, where a sell signal is accepted only if there is profit to be made. </p>

<p>To cross validate, the training set was split into 4 segments (2.5 years each), and the absolute return was calculated on each segment using the lossless trading behavior described above.  The minimum of the returns from the four segments was used as the fitness for the entire trading rule. The genetic algorithm was run for 500 generations for each stock ticker. </p>

<h4>Mutation, Recombination, and Polyclonality</h4>
<p>At the start of each generation, each trading strategy in the population was mutated with a certain probability. The mutations altered the trees by changing randomly the input indicators (Table 2) (probability = P = 0.1), the length of the moving window (P = 0.05), the constant of multiplication for the multiplication operator (P =  0.5, gaussian proposal distribution step size = 1), or the operations at the nodes (Table 1) (P = 0.05). Care was taken to ensure that nodes containing boolean operations remained boolean after mutation. </p>
<p>Two types of recombination were defined and both recombination rules were each applied to 30 randomly selected pairs of trading strategies at each generation. The first type of recombination was performed by swapping sub-branches between the buy or the sell trees of each trading strategy. The second recombination defined was a simple swapping of entire buy or sell trees between any two trading strategies. </p>
<p>Polyclonality is defined as the number of unique trading strategies in the population and was monitored over the course of evolution. When polyclonality dropped to 20 or below, the current population would be replaced by a population mutated from the most optimal solution in the evolutionary history. </p>

<h4>Analysis of results</h4>
<p>For each of the optimal trading strategies from each stock ticker GP run, a realistic return was calculated as the percent return in excess of a S&P 500 buy-and-hold strategy (+23.7% in the training period and +3.88% in the test period). A fixed 0.1% transaction cost was implemented per transaction, corresponding to a $7 fixed fee [13] from investing in batches of stocks worth $7000. We thus define the annualized adjusted excess return as the annualized percent return in excess of a buy-and-hold strategy on the S&P500 index in the same time period, minus a 0.1% transaction cost. </p>

<h4>Tree Similarity Calculation</h4>
<p>To compare the trading strategies from each of the 312 GP runs, a similarity score was developed. Each buy and sell tree from each trading strategy was applied on 15000 days of S&P 500 historical data, producing a 15000 entry binary vector corresponding to buy/sell signals. The euclidian distance between these vectors were calculated for all pairwise tree comparisons. The additive inverse normalized distance was then used to generate a similarity score from 0 to 1. This “functional” comparison was rationalized because similar trees should, in principle, generate similar buy/sell signals. </p>
<p>Figure 5 shows two buy trees (A&B) that were deemed similar (scoreAB = 0.940) and a third tree (C) that was deemed not similar compared to the other two (scoreAC = 0.0003, scoreBC = 0.0015). In broad strokes, one could rationalize why trees A and B might have been scored as similar. The root (top) node of tree B can be flipped such that the root operation of both trees A and B are “greater than” a certain volume lag. In addition, it is plausible that the current volume minus the minimum volume over the last three days (tree B) is an approximation of the standard deviation of volume over the last 8 days (tree A). Certainly, these trees produced very similar buy signals over the course of roughly 41 years on the S&P 500 index, suggesting that they are functionally similar even though it may be hard to intuitively rationalize why they would be. It is also clear that tree C is different from A and B because it includes price data that is combined with volume data.</p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940865/3161a518-d991-11e3-8d4b-e324c29cadfc.png"style="display: block;
    margin-left: auto;
    margin-right: auto"/>
      <small><strong>Figure 5. Buy signal trees from trading strategies optimized with GP on tickers (A) AAPL, (B) ADM, and (C) AON.</strong> Trees A and B were scored as similar (scoreAB = 0.940) based on comparing the buy signal vectors on 15000 days of S&P index data.  Tree C was deemed different from the other two (scoreAC = 0.0003, scoreBC = 0.0015). 
 </small>




<h3>
<a name="conc" class="anchor" href="#conc"><span class="octicon octicon-link"></span></a>Conclusions and Future Directions</h3>

<p>Genetic programming was used to select a set of trees that performed well on each of the 312 S&P 500 stock tickers studied. The annualized adjusted excess return is defined as the percentage return in excess of that from a buy-and-hold strategy on the S&P 500 index with a 0.1% transaction fee. Averaging over the portfolio of 312 trading strategies generated with GP, the mean annualized adjusted excess return is 105.6% and 11.4% in the training period and in the test period, respectively. </p>
<p>Evidence of overfitting in the current model suggests that there is more model optimization and validation to be done. One way to approach the problem is to split the training data into more validation sets, which would reduce the tendency for a specific part of the training data to disproportionately affect the fitness. Another approach is to train the trading strategies on longer periods of training data, potentially giving the algorithm exposure to a greater range of price movement patterns. In order to improve the training and test set returns, more operations and indicators could be included, such as the Price-Earnings Ratio. Historic Price-Earnings Ratios are not provided by Yahoo! Finance, so it was not included in the current project due to time constraints. </p>
<p>It would also be interesting to apply each generated trading strategy on stock tickers that were not used to train it. This would give an indication of how generalizable specific trading strategies are to other stock tickers and whether the GP overfit trading strategies to the ticker data used to train it. </p>
<p>GP was shown to be a powerful method for selecting profitable trading strategies given a large number of operations and the resultant high dimension of possible trading strategy trees. The results suggest that indeed, a trading algorithm which customizes strategies to individual stocks of a portfolio is better able to exploit market inefficiencies compared to an algorithm that only optimizes over the combined index.   </p>
  
<h3>
<a name="refs" class="anchor" href="#refs"><span class="octicon octicon-link"></span></a>References</h3>


<ol>
<li>Ratner, M., & Leal, R. P. (1999). Tests of technical trading strategies in the emerging equity markets of Latin America and Asia. <em>Journal of Banking & Finance, 23</em>(12), 1887-1905. </li>
<li>Gencay, R. (1998). Optimization of technical trading strategies and the profitability in security markets. <em>Economics Letters, 59</em> (2), 249-254. </li>
<li>El-Khateeb, E., Radi, A., El-Bakry, S. Y., & El-Bakry, M. Y. (2014). Modeling Hadronic Collisions Using Genetic Programming Approach. </li>
<li>Elhenawy, M., Chen, H., & Rakha, H. A. (2014). Dynamic travel time prediction using data clustering and genetic programming. <em>Transportation Research Part C: Emerging Technologies, 42</em>, 82-98. </li>
<li>Harvey, D., & Todd, M. (2014). Automated selection of damage detection features by genetic programming. In <em>Topics in Modal Analysis, Volume 7</em> (pp. 9-16). Springer New York. </li>
<li>Allen, F., & Karjalainen, R. (1999). Using genetic algorithms to find technical trading strategies. <em>Journal of financial Economics, 51</em> (2), 245-271. </li>
<li>Brock, W., Lakonishok, J., & LeBaron, B. (1992). Simple technical trading strategies and the stochastic properties of stock returns. <em>The Journal of Finance, 47</em> (5), 1731-1764. </li>
<li>Chen, S. H., & Yeh, C. H. (1997). Toward a computable approach to the efficient market hypothesis: an application of genetic programming. <em>Journal of Economic Dynamics and Control, 21</em> (6), 1043-1063. </li>
<li>Dempster, M. A. H., Payne, T. W., Romahi, Y., & Thompson, G. W. (2001). Computational learning techniques for intraday FX trading using popular technical indicators. <em>Neural Networks, IEEE Transactions on, 12</em> (4), 744-754. </li>
<li>Neely, C., Weller, P., & Dittmar, R. (1997). Is technical analysis in the foreign exchange market profitable? A genetic programming approach. <em>Journal of Financial and Quantitative Analysis, 32</em> (04), 405-426. </li>
<li>Potvin, J. Y., Soriano, P., & Vallée, M. (2004). Generating trading strategies on the stock markets with genetic programming. Computers & Operations Research, 31(7), 1033-1047. </li>
<li>Bollinger, J. (2001). <em>Bollinger on Bollinger bands</em>. McGraw Hill Professional. </li>
<li>Merrill Edge. (2014). Pricing. http://www.merrilledge.com/pricing</li>
<li>Malkiel, B. G., & Fama, E. F. (1970). Efficient capital markets: A review of theory and empirical work*. <em>The journal of Finance, 25</em>(2), 383-417. </li>
</ol>
  
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/72L">72L</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
