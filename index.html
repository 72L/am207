<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Am207 by 72L</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Genetic Programming for the Computational Discovery of Trading Rules</h1>
        <p>AM207 Spring 2014 Final Project</p>

        <p class="view"><a href="https://github.com/72L/am207">View the Project on GitHub <small>72L/am207</small></a></p>

      </header>
      <section>
        <h3>
<a name="intro-and-theory" class="anchor" href="#intro-and-theory"><span class="octicon octicon-link"></span></a>Introduction and Theory</h3>

<h4>What are Trading Strategies?</h4>

<p>Technical trading strategies are used to determine buy and sell signals based on time series stock data. In the purest sense, trading strategies operate with only input from time series data and do not consider fundamentals (i.e. balance sheets, news, income statements) used by analysts considering a company’s inherent value. Instead, trading strategies employ indicators, which are derived time series calculated from raw price or volume time series data. For example, one possible technical trading strategy could use the 200-day moving average (MA(200)) and the 50-day moving average (MA(50)) indicators. A buy signal is generated when the MA(50) crosses above the MA(200), signalling a recent upward trend. Conversely, a sell signal would be generated when the MA(50) crosses below the MA(200). Other commonly used indicators include moving window standard deviations and momentum, which is the price difference between the ends of a moving window.
</p>

<p>Trading strategies explored by academics have been met with varying levels of success. Ratner et al. tested a series of moving average trading strategies on different world markets, but found that transaction costs diminished most of the gains made relative to a buy-and-hold strategy [1]. Strictly speaking, technical trading strategies do not predict future prices. Rather, indicators are used to generate buy/sell signals in real time with present and historical data. Some researchers have combined methods of prediction with trading strategies to great success [2]; however, the current project will focus solely on trading strategies.</p>

<h4>Motivation</h4>
<p>The trading strategies described thus far have some heuristic rationalization because they were developed by humans. It is reasonable to posit, however, that successful trading rules should not be limited by human intuition or experience. This project addresses whether new, unintuitive, and profitable trading strategies can be discovered with a stochastic algorithm called genetic programming. New strategies generated this way may perhaps capture underlying, yet unknown trends in the market.</p>

<h4>What is Genetic Programming?</h4>
<p>Genetic algorithms optimize a fitness function by simulating natural selection. Members of a population, which represent candidate solutions, are mutated randomly over time. At each time step or generation, each member is given probability to reproduce clones proportional to their respective fitness. If designed well, over time, the population will achieve higher and higher fitness, eventually reaching the optimal point of the fitness function. </p>
<p>Genetic programming (GP), a type genetic algorithm, optimizes a set of rules or programs that transform data in highly non-linear ways. Programs are represented as trees, where each node is an operation performed with the two subtrees of data below it. Results of each operation node are successively combined from the bottom up. The final dataset is the output of the highest level node, processed by all the operations below it. Recent studies have applied the genetic programming framework to model hadronic collisions [3], predict travel time [4], and predict the consumption of natural gas [5]. </p>
<p>Genetic programming has been used extensively in the field of finance to generate and evaluate trading strategies, which are easily represented as trees (see below). GP has been used to generate trading strategies for US indices (S&P500 and Dow Jones Index) [6, 7, 8], Foreign exchange markets [9, 10], and individual Canadian stocks [11]. These studies were not able to obtain rules that provided consistent returns on a risk-adjusted basis, especially with transaction costs.</p>

<h4>What did I do?</h4>
<p>In this project, I use Genetic Programming to generate and evaluate trading strategies on individual S&P 500 stock tickers. Perhaps an approach that uses customized strategies for each stock in a portfolio will be able to better exploit market inefficiencies (and therefore achieve better returns) compared to a strategy that trades solely with the entire index.</p>



<h3>
<a name="data" class="anchor" href="#data"><span class="octicon octicon-link"></span></a>Data</h3>

<p>Historical daily adjusted closing prices and volumes from years 1999 to 2013 of stocks in the S&P 500 were downloaded from Yahoo! Finance. Only stocks with at least 15 years of history available on Yahoo! Finance were considered (n = 312). This allowed splitting of the time series data into a 10-year training set (1999 to 2008) and a 5-year test set (2009 to 2013). </p>
<p>The Global Industry Classification Standard (GICS) sector labels given to each ticker were used for sector analysis. Our data set of 312 tickers contained 48 tickers from the Financials sector, 47 from Industrials, 42 from Consumer Discretionary, 34 from Health Care, 33 from Information Technology, 28 from Consumer Staples, 27 from Energy, 26 from Utilities, 23 from Materials, and 4 from Telecommunications Services. </p>



<h3>
<a name="approach" class="anchor" href="#approach"><span class="octicon octicon-link"></span></a>Approach</h3>

<h4>Trading Strategy Tree Representation</h4>
<p>A trading strategy is composed of two trees: one that encodes the buy signals and one that encodes the sell signals. For example, a possible trading strategy using Bollinger Bands [12] is represented by the two trees in the figure below. A sell signal is generated when the sell tree returns true. That is, the investor will sell when the price falls below the lower bollinger band, which is calculated as MA(20) - 2*SD(20) , where MA(x)  and SD(x) are the x-day moving window average and standard deviation, respectively. Similarly, a buy signal is generated when the price rises above the upper bollinger band, calculated as MA(20) + 2*SD(20).</p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940863/315caaf4-d991-11e3-8f6f-d29256c5155e.png"/>

<p>To construct the trading strategy trees, a set of seven operations were defined (Table 1). These operations comprise the joining nodes, such as those represented by circles in Figure 1.
</p>

<table cellpadding="0" cellspacing="0" class="c39"><tbody><tr class="c35"><td class="c26"><p class="c21"><span class="c1 c3">O</span><span class="c1 c3">perations</span></p></td><td class="c22"><p class="c21"><span class="c44 c1 c3">Input</span></p></td><td class="c36"><p class="c21"><span class="c1 c3 c44">Output</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Add (+)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">the vector sum</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Subtract (-)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">the vector difference (order dependence)</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Norm </span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">the absolute value of the vector difference </span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Multiply (x)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">a scalar and a time series vector</span></p></td><td class="c36"><p class="c10"><span class="c3 c2 c7">the scalar multiple of the time series vector</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c3 c2">Divide (</span><span class="c3 c2 c27">&divide;)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">each entry of the first vector is divided by the second (order dependence)</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Greater Than (&gt;)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">Boolean of entry-wise comparison (order dependence)</span></p></td></tr><tr class="c32"><td class="c26"><p class="c10"><span class="c7 c3 c2">Less Than (&lt;)</span></p></td><td class="c22"><p class="c10"><span class="c7 c3 c2">two time series vectors</span></p></td><td class="c36"><p class="c10"><span class="c7 c3 c2">Boolean of entry-wise comparison (order dependence)</span></p></td></tr></tbody></table>

<p>Operations act on a set of indicators (Table 2), such as those represented by rectangles in Figure 1. The derived indicators were pre-calculated from the raw price or volume data before GP simulation. This allowed fast evaluation of the trading strategy trees. 
</p>
<p>Moving windows used in the calculation of the derived time series were chosen from a truncated Fibonacci number set, where numbers above 10 continue to increase by multiples of 10 up to 365. This was chosen arbitrarily to limit the number of pre-calculated time series that had to be stored onto system memory. </p>
<p>The simulation was initialized with a population of 300 identical Bollinger Band trading strategy tree pairs.  The set of 300 was mutated as described below to produce an initial population. The population size of 300 was kept constant.</p>

<h4>Fitness</h4>

<p>Given the buy and sell signals calculated from the trading strategies, the fitness function was determined by simulating the sequential buying and selling of one share of the stock. Thus, two consecutive buy signals would only result in one action - the first buy. “Lossless” trading behavior is implemented, where a sell signal is accepted only if there is profit to be made. </p>
<p>The absolute return minus a small $0.01/stock transaction cost was used as a measure of fitness during evolution. The transaction cost was included to penalize strategies with too many transactions (overfitting), yet the cost was made small to limit this effect on the genetic algorithm. For data analysis of trees after GP selection, a more realistic 0.1% transaction cost was used (see below). </p>
<p>To cross validate, the training set was split into 4 segments (2.5 years each), and the absolute return was calculated on each segment using the lossless trading behavior described above.  The minimum of the returns from the four segments was used as the fitness for the entire trading rule. At each time step or generation, trading strategies (represented as trees) were given probability to reproduce clones proportional to their respective fitness. The genetic algorithm was run for 500 generations for each stock ticker. </p>

<h4>Mutation, Recombination, and Polyclonality</h4>
<p>At the start of each generation, each trading strategy in the population was mutated with a certain probability. The mutations altered the trees by changing randomly the input indicators (Table 2) (probability = P = 0.1), the length of the moving window (P = 0.05), the constant of multiplication for the multiplication operator (P =  0.5, gaussian proposal distribution step size = 1), or the operations at the nodes (Table 1) (P = 0.05). Care was taken to ensure that nodes containing boolean operations remained boolean after mutation. </p>
<p>Two types of recombination were defined and both recombination rules were each applied to 30 randomly selected pairs of trading strategies at each generation. The first type of recombination was performed by swapping sub-branches between the buy or the sell trees of each trading strategy. The second recombination defined was a simple swapping of entire buy or sell trees between any two trading strategies. </p>
<p>Polyclonality is defined as the number of unique trading strategies in the population and was monitored over the course of evolution. When polyclonality dropped to 20 or below, the current population would be replaced by a population mutated from the most optimal solution in the evolutionary history. </p>

<h4>Analysis of results</h4>
<p>For each of the optimal trading strategies from each stock ticker GP run, a realistic return was calculated as the percent return in excess of a S&P 500 buy-and-hold strategy (+23.7% in the training period and +3.88% in the test period). A fixed 0.1% transaction cost was implemented per transaction, corresponding to a $7 fixed fee [13] from investing in batches of stocks worth $7000. We thus define the annualized adjusted excess return as the annualized percent return in excess of a buy-and-hold strategy on the S&P500 index in the same time period, minus a 0.1% transaction cost. </p>

<h4>Tree Similarity Calculation</h4>
<p>To compare the trading strategies from each of the 312 GP runs, a similarity score was developed. Each buy and sell tree from each trading strategy was applied on 15000 days of S&P 500 historical data, producing a 15000 entry binary vector corresponding to buy/sell signals. The euclidian distance between these vectors were calculated for all pairwise tree comparisons. The additive inverse normalized distance was then used to generate a similarity score from 0 to 1. This “functional” comparison was rationalized because similar trees should, in principle, generate similar buy/sell signals. </p>
<p>Figure 2 shows two buy trees (A&B) that were deemed similar (scoreAB = 0.940) and a third tree (C) that was deemed not similar compared to the other two (scoreAC = 0.0003, scoreBC = 0.0015). In broad strokes, one could rationalize why trees A and B might have been scored as similar. The root (top) node of tree B can be flipped such that the root operation of both trees A and B are “greater than” a certain volume lag. In addition, it is plausible that the current volume minus the minimum volume over the last three days (tree B) is an approximation of the standard deviation of volume over the last 8 days (tree A). Certainly, these trees produced very similar buy signals over the course of roughly 41 years on the S&P 500 index, suggesting that they are functionally similar even though it may be hard to intuitively rationalize why they would be. It is also clear that tree C is different from A and B because it includes price data that is combined with volume data.</p>

<img src="https://cloud.githubusercontent.com/assets/5567899/2940865/3161a518-d991-11e3-8d4b-e324c29cadfc.png"/>



<h3>
<a name="results" class="anchor" href="#results"><span class="octicon octicon-link"></span></a>Results</h3>








<h3>
<a name="support-or-contact" class="anchor" href="#support-or-contact"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble with Pages? Check out the documentation at <a href="http://help.github.com/pages">http://help.github.com/pages</a> or contact <a href="mailto:support@github.com">support@github.com</a> and we’ll help you sort it out.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/72L">72L</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
